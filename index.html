<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Ultra Green DJ Decks ‚Äî GitHub Page</title>
  <style>
    :root{
      --bg:#050807; --panel:#0a1110; --line:#0f1a18;
      --fg:#eafff4; --muted:#9fd0c0; --glow:#35ff9a; --glow2:#7bffc8; --accent:#1cff88;
      --wrapW:1200px; --gap:14px; --waveH:150px; --ctlW:220px;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#000,#020805 60%, #00110b);color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    *{box-sizing:border-box;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
    body{touch-action:manipulation}

    /* Appear button (left edge, 3/4 down) */
    .edge-left{
      position:fixed; left:10px; top:75vh; transform:translateY(-50%); z-index:9999;
      padding:12px 16px; border-radius:14px; cursor:pointer;
      background:#07120e; color:#eafff4; border:1px solid #0f261e;
      box-shadow:0 0 12px var(--glow), 0 0 24px var(--glow2); text-shadow:0 0 6px var(--glow), 0 0 12px var(--glow2);
    }
    .edge-left.pulse{animation:gpulse 1.4s ease-in-out infinite}
    @keyframes gpulse{0%,100%{box-shadow:0 0 12px var(--glow),0 0 24px var(--glow2)}50%{box-shadow:0 0 18px var(--glow),0 0 40px var(--glow2)}}

    /* Panel shell */
    #decks-panel{transition:opacity .25s ease, transform .25s ease}
    #decks-panel[hidden]{opacity:0; transform:translateX(-8px); pointer-events:none}
    .wrap{max-width:min(var(--wrapW),98vw); margin:16px auto; padding:10px}

    .panel{background:linear-gradient(180deg,#07100d,#091613); border:1px solid #0f1a18; border-radius:14px; padding:12px; box-shadow:0 0 0 1px #0a1714, 0 0 25px rgba(53,255,154,.12)}
    .row{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap}
    .center{justify-content:center}
    .muted{color:var(--muted); font-size:12px}
    .h{font-weight:700; letter-spacing:.3px}
    .glowTxt{text-shadow:0 0 8px var(--glow), 0 0 18px var(--glow2)}

    .btn{border:1px solid #0f261e; background:#07120e; color:var(--fg); padding:10px 14px; border-radius:12px; cursor:pointer; box-shadow:0 0 0 1px #0a1714, 0 0 18px rgba(28,255,136,.15) inset}
    .btn.hot{background:radial-gradient(100% 100% at 50% 0%, #0e2a1f, #0a1714); border-color:#124f3b}
    .btn.rec{background:#1a0b0e; border-color:#2b0f16; box-shadow:0 0 12px rgba(255,77,109,.35) inset, 0 0 24px rgba(255,77,109,.18)}

    input[type=range], input[type=file]{appearance:none;-webkit-appearance:none;background:#07120e;color:var(--fg);border:1px solid #103127;border-radius:10px;padding:8px 10px;box-shadow:0 0 0 1px #0a1714 inset, 0 0 16px rgba(53,255,154,.12) inset;font-size:14px;width:var(--ctlW)}
    input[type=range]{height:28px}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:10px;background:var(--glow);box-shadow:0 0 8px var(--glow),0 0 18px var(--glow2)}
    input[type=range]::-moz-range-thumb{width:18px;height:18px;border:none;border-radius:10px;background:var(--glow);box-shadow:0 0 8px var(--glow),0 0 18px var(--glow2)}
    .tag{font-size:12px; padding:6px 8px; border:1px solid #0f261e; border-radius:10px; background:#07120e; color:var(--muted)}

    .topGrid{display:grid; grid-template-columns:1fr auto 1fr; gap:var(--gap); align-items:center}
    @media (max-width:980px){ .topGrid{grid-template-columns:1fr; justify-items:center} :root{--ctlW:180px} }

    .decksGrid{display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); align-items:start}
    @media (max-width:980px){ .decksGrid{grid-template-columns:1fr} }

    .deck{display:flex; flex-direction:column; gap:12px}
    .wavebox{position:relative; background:#05100c; border:1px solid #0e241d; border-radius:12px; padding:8px}
    canvas.wave{width:100%; height:var(--waveH); display:block; border-radius:8px; background:linear-gradient(180deg,#04110c,#071a14 60%, #03100b); box-shadow:inset 0 0 25px rgba(53,255,154,.08)}
    .playhead{position:absolute; top:8px; bottom:8px; width:2px; left:8px; background:var(--accent); box-shadow:0 0 10px var(--accent)}

    .meters{display:flex; gap:8px; align-items:center}
    .meter{width:8px; height:42px; background:#0b1714; border:1px solid #103127; border-radius:4px; position:relative; overflow:hidden}
    .meter>.fill{position:absolute; bottom:0; left:0; width:100%; height:30%; background:linear-gradient(180deg,var(--glow2),var(--glow)); box-shadow:0 0 12px var(--glow)}
  </style>
</head>
<body>

  <!-- Appear button -->
  <button id="btn-appear" class="edge-left">‚ñ≤ Appear</button>

  <!-- Main decks panel (hidden initially) -->
  <div id="decks-panel" hidden>
    <div class="wrap" id="ultraWrap">

      <!-- Top bar -->
      <div class="panel topGrid">
        <!-- Left: Deck A -->
        <div class="row center">
          <button id="playA" class="btn hot">‚ñ∂ A</button>
          <button id="pauseA" class="btn">‚ùö‚ùö</button>
          <label class="tag">Vol A <input id="volA" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <label class="tag">Load A <input id="fileA" type="file" accept="audio/*"></label>
        </div>
        <!-- Middle: Hide + Master + meters -->
        <div class="row center">
          <button id="btn-hide" class="btn">‚úñ Hide</button>
          <label class="tag">Master <input id="masterVol" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <div class="meters">
            <div class="meter"><div id="mA" class="fill" style="height:10%"></div></div>
            <div class="meter"><div id="mB" class="fill" style="height:10%"></div></div>
          </div>
        </div>
        <!-- Right: Deck B -->
        <div class="row center">
          <label class="tag">Load B <input id="fileB" type="file" accept="audio/*"></label>
          <label class="tag">Vol B <input id="volB" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <button id="pauseB" class="btn">‚ùö‚ùö</button>
          <button id="playB" class="btn hot">‚ñ∂ B</button>
        </div>
      </div>

      <!-- Decks -->
      <div class="decksGrid">
        <section class="panel deck" id="deckA">
          <div class="h glowTxt" style="text-align:center">Deck A</div>
          <div class="wavebox">
            <canvas id="waveA" class="wave"></canvas>
            <div id="headA" class="playhead"></div>
          </div>
          <div class="row center">
            <button id="cueSetA" class="btn">Set Cue</button>
            <button id="cueGoA" class="btn">Cue ‚ñ∂</button>
            <label class="tag">Seek A <input id="seekA" type="range" min="0" max="1" step="0.001" value="0"></label>
          </div>
        </section>

        <section class="panel deck" id="deckB">
          <div class="h glowTxt" style="text-align:center">Deck B</div>
          <div class="wavebox">
            <canvas id="waveB" class="wave"></canvas>
            <div id="headB" class="playhead"></div>
          </div>
          <div class="row center">
            <button id="cueSetB" class="btn">Set Cue</button>
            <button id="cueGoB" class="btn">Cue ‚ñ∂</button>
            <label class="tag">Seek B <input id="seekB" type="range" min="0" max="1" step="0.001" value="0"></label>
          </div>
        </section>
      </div>

      <!-- Mixer -->
      <div class="panel">
        <div class="row center">
          <span class="muted">A</span>
          <input id="xfade" type="range" min="0" max="1" step="0.001" value="0" style="width:min(560px, 90vw)">
          <span class="muted">B</span>
        </div>
      </div>

      <!-- Recorder -->
      <div class="panel">
        <div class="row center">
          <button id="recBtn" class="btn rec">‚óè Record</button>
          <span id="recLamp" style="width:14px;height:14px;border-radius:999px;background:#193b30; box-shadow:0 0 0 2px #0b1a14 inset; display:inline-block"></span>
          <button id="dlBtn" class="btn" disabled>Download Mix</button>
          <span class="muted">Format: audio/webm</span>
        </div>
      </div>

      <p class="muted" style="text-align:center">Drag waveforms to seek. Crossfader is equal-power. Everything glows green üå±</p>
    </div>
  </div>

  <script>
    // Prevent mobile copy/long-press UI
    addEventListener('contextmenu', e=> e.preventDefault(), {passive:false});
    addEventListener('selectstart', e=> e.preventDefault(), {passive:false});
    addEventListener('gesturestart', e=> e.preventDefault(), {passive:false});

    // Appear / Hide
    const panel = document.getElementById('decks-panel');
    const appearBtn = document.getElementById('btn-appear');
    const hideBtn = document.getElementById('btn-hide');
    appearBtn.addEventListener('click', ()=>{ panel.hidden=false; appearBtn.classList.remove('pulse'); });
    hideBtn.addEventListener('click', ()=>{ panel.hidden=true;  appearBtn.classList.add('pulse'); });
    panel.hidden = true; appearBtn.classList.add('pulse');

    // Audio
    let ctx, master, recDest, mediaRec, chunks=[], isRec=false;
    function makeDeck(){ return {fileEl:null,playBtn:null,pauseBtn:null,volEl:null,seekEl:null,waveCan:null,waveCtx:null,headEl:null,meterFill:null,buffer:null,src:null,gain:null,xGain:null,analyser:null,isPlaying:false,startTime:0,offset:0,cue:0}; }
    const deckA = makeDeck(), deckB = makeDeck();

    function initAudio(){
      if (ctx) return;
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value = parseFloat(document.getElementById('masterVol').value||1);
      recDest = ctx.createMediaStreamDestination(); master.connect(recDest); master.connect(ctx.destination);
      [deckA, deckB].forEach(d=>{ d.gain=ctx.createGain(); d.gain.gain.value=1; d.xGain=ctx.createGain(); d.xGain.gain.value=1; d.analyser=ctx.createAnalyser(); d.analyser.fftSize=2048; d.gain.connect(d.xGain).connect(d.analyser).connect(master); });
      applyCrossfade(parseFloat(document.getElementById('xfade').value||0));
    }

    function loadFileToDeck(file, deck){
      if(!file) return; initAudio();
      const fr=new FileReader();
      fr.onload = async e=>{
        try{
          const buf = await ctx.decodeAudioData(e.target.result);
          deck.buffer=buf; deck.offset=0; deck.cue=0; deck.seekEl.value=0;
          drawWave(deck); stopDeck(deck); prepareSource(deck);
        }catch(err){ console.error(err); alert('Could not decode that audio file.'); }
      };
      fr.readAsArrayBuffer(file);
    }

    function prepareSource(deck){ if(!deck.buffer) return; if(deck.src){try{deck.src.disconnect();}catch{} deck.src=null;} const s=ctx.createBufferSource(); s.buffer=deck.buffer; s.connect(deck.gain); deck.src=s; }
    function playDeck(deck){ if(!deck.buffer) return; initAudio(); if(deck.isPlaying) return; prepareSource(deck); deck.startTime=ctx.currentTime-deck.offset; deck.src.start(0,deck.offset); deck.isPlaying=true; deck.src.onended=()=>{ if(deck.isPlaying){ deck.isPlaying=false; deck.offset=0; deck.seekEl.value=0; prepareSource(deck);} }; }
    function pauseDeck(deck){ if(!deck.isPlaying) return; try{deck.src.stop();}catch{} deck.offset=Math.min(deck.buffer.duration, Math.max(0, ctx.currentTime-deck.startTime)); deck.isPlaying=false; prepareSource(deck); }
    function stopDeck(deck){ if(deck.isPlaying){try{deck.src.stop();}catch{}} deck.isPlaying=false; deck.offset=0; deck.seekEl.value=0; prepareSource(deck); }

    function setSeek(deck, norm){ if(!deck.buffer) return; const pos=norm*deck.buffer.duration; const was=deck.isPlaying; if(was) pauseDeck(deck); deck.offset=pos; deck.seekEl.value=norm; if(was) playDeck(deck); drawHeads(); }
    function setCue(deck){ if(deck.buffer) deck.cue = deck.offset; }
    function goCue(deck){ if(!deck.buffer) return; const was=deck.isPlaying; if(was) pauseDeck(deck); deck.offset=Math.min(deck.buffer.duration, Math.max(0, deck.cue)); deck.seekEl.value=deck.offset/deck.buffer.duration; if(was) playDeck(deck); }

    function applyCrossfade(x){ const gA=Math.cos(0.5*Math.PI*x); const gB=Math.cos(0.5*Math.PI*(1-x)); deckA.xGain.gain.value=gA*gA; deckB.xGain.gain.value=gB*gB; }
    function analyserLevel(an){ const arr=new Uint8Array(an.frequencyBinCount); an.getByteTimeDomainData(arr); let sum=0; for(let i=0;i<arr.length;i++){const v=(arr[i]-128)/128; sum+=v*v;} return Math.min(1, Math.sqrt(sum/arr.length)*1.8); }

    function drawWave(deck){
      const cvs=deck.waveCan, c=deck.waveCtx;
      const W=cvs.width=Math.floor(cvs.clientWidth*devicePixelRatio);
      const H=cvs.height=Math.floor(cvs.clientHeight*devicePixelRatio);
      c.clearRect(0,0,W,H);
      if(!deck.buffer){ c.fillStyle='rgba(28,255,136,.06)'; c.fillRect(0,0,W,H); return; }
      const ch=deck.buffer.getChannelData(0), samples=Math.max(1,W), block=Math.max(1,Math.floor(ch.length/samples));
      c.lineWidth=Math.max(1,Math.floor(1.2*devicePixelRatio)); c.strokeStyle='#35ff9a'; c.shadowColor='#35ff9a'; c.shadowBlur=10;
      c.beginPath();
      for(let x=0;x<samples;x++){ const s=x*block, e=Math.min(ch.length,s+block); let mn=1e9,mx=-1e9; for(let i=s;i<e;i++){const v=ch[i]; if(v<mn)mn=v; if(v>mx)mx=v;} const y1=(1-mn)*0.5*H, y2=(1-mx)*0.5*H; c.moveTo(x,y1); c.lineTo(x,y2); }
      c.stroke(); c.shadowBlur=0; c.strokeStyle='rgba(124,255,200,.18)'; c.beginPath(); c.moveTo(0,H/2); c.lineTo(W,H/2); c.stroke();
    }
    function drawHeads(){
      [[deckA,'headA'],[deckB,'headB']].forEach(([d,id])=>{
        const head=d.headEl, wave=d.waveCan;
        if(d.buffer){ const dur=d.buffer.duration, off=d.isPlaying?(ctx.currentTime-d.startTime):d.offset; const norm=Math.min(1,Math.max(0,off/dur)); const px=8+norm*(wave.clientWidth-16); head.style.left=px+'px'; }
        else head.style.left='8px';
      });
    }

    function $(id){return document.getElementById(id)}
    function bindDeck(deck, ids){
      deck.playBtn=$$(ids.play); deck.pauseBtn=$$(ids.pause); deck.fileEl=$$(ids.file);
      deck.volEl=$$(ids.vol); deck.seekEl=$$(ids.seek); deck.waveCan=$$(ids.wave);
      deck.waveCtx=deck.waveCan.getContext('2d'); deck.headEl=$$(ids.head); deck.meterFill=$$(ids.meter);

      deck.fileEl.addEventListener('change', e=> loadFileToDeck(e.target.files[0], deck));
      deck.playBtn.addEventListener('click', ()=> playDeck(deck));
      deck.pauseBtn.addEventListener('click', ()=> pauseDeck(deck));
      deck.volEl.addEventListener('input', ()=> { initAudio(); deck.gain.gain.value=parseFloat(deck.volEl.value||1); });
      deck.seekEl.addEventListener('input', ()=> setSeek(deck, parseFloat(deck.seekEl.value)));

      let dragging=false;
      function normFromEvent(ev){ const r=deck.waveCan.getBoundingClientRect(); const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-r.left; return Math.min(1,Math.max(0,x/r.width)); }
      deck.waveCan.addEventListener('pointerdown', e=>{dragging=true; setSeek(deck, normFromEvent(e)); deck.waveCan.setPointerCapture(e.pointerId);});
      deck.waveCan.addEventListener('pointermove', e=>{if(dragging) setSeek(deck, normFromEvent(e));});
      deck.waveCan.addEventListener('pointerup', e=>{dragging=false; try{deck.waveCan.releasePointerCapture(e.pointerId);}catch{}});
      deck.waveCan.addEventListener('pointerleave', ()=>{dragging=false;});

      new ResizeObserver(()=> drawWave(deck)).observe(deck.waveCan);
    }
    function $$(id){return document.getElementById(id)}

    bindDeck(deckA,{play:'playA',pause:'pauseA',file:'fileA',vol:'volA',seek:'seekA',wave:'waveA',head:'headA',meter:'mA'});
    bindDeck(deckB,{play:'playB',pause:'pauseB',file:'fileB',vol:'volB',seek:'seekB',wave:'waveB',head:'headB',meter:'mB'});

    $('cueSetA').addEventListener('click', ()=> setCue(deckA));
    $('cueGoA').addEventListener('click',  ()=> goCue(deckA));
    $('cueSetB').addEventListener('click', ()=> setCue(deckB));
    $('cueGoB').addEventListener('click',  ()=> goCue(deckB));

    $('xfade').addEventListener('input', e=> applyCrossfade(parseFloat(e.target.value)));
    $('masterVol').addEventListener('input', e=> { initAudio(); master.gain.value=parseFloat(e.target.value||1); });

    const recBtn=$('recBtn'), dlBtn=$('dlBtn'), recLamp=$('recLamp');
    recBtn.addEventListener('click', ()=>{
      initAudio();
      if(!mediaRec){
        const stream=recDest.stream;
        try{ mediaRec=new MediaRecorder(stream,{mimeType:'audio/webm'});}catch(e){ mediaRec=new MediaRecorder(stream); }
        mediaRec.ondataavailable=e=>{ if(e.data?.size) chunks.push(e.data); };
        mediaRec.onstop=()=>{ const blob=new Blob(chunks,{type:chunks[0]?.type||'audio/webm'}); chunks=[]; const url=URL.createObjectURL(blob); dlBtn.disabled=false; dlBtn._url=url; };
      }
      if(!isRec){ chunks=[]; mediaRec.start(150); isRec=true; recLamp.style.background='#ff445f'; recLamp.style.boxShadow='0 0 10px #ff445f, 0 0 22px rgba(255,68,95,.55)'; recBtn.textContent='‚ñ† Stop'; }
      else{ mediaRec.stop(); isRec=false; recLamp.style.background='#193b30'; recLamp.style.boxShadow='0 0 0 2px #0b1a14 inset'; recBtn.textContent='‚óè Record'; }
    });
    dlBtn.addEventListener('click', e=>{ if(!dlBtn._url){e.preventDefault();return;} const a=document.createElement('a'); a.href=dlBtn._url; a.download='UltraMix.webm'; document.body.appendChild(a); a.click(); a.remove(); });

    function tick(){
      if(ctx){
        [deckA,deckB].forEach(d=>{
          if(d.isPlaying){
            const newOff=ctx.currentTime-d.startTime;
            if(newOff>=d.buffer.duration){ d.isPlaying=false; d.offset=0; d.seekEl.value=0; prepareSource(d); }
          }
          if(d.analyser && d.meterFill){ d.meterFill.style.height=Math.round(analyserLevel(d.analyser)*100)+'%'; }
        });
        drawHeads();
      }
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html><!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Ultra Green DJ Decks ‚Äî GitHub Page</title>
  <style>
    :root{
      --bg:#050807; --panel:#0a1110; --line:#0f1a18;
      --fg:#eafff4; --muted:#9fd0c0; --glow:#35ff9a; --glow2:#7bffc8; --accent:#1cff88;
      --wrapW:1200px; --gap:14px; --waveH:150px; --ctlW:220px;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#000,#020805 60%, #00110b);color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    *{box-sizing:border-box;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
    body{touch-action:manipulation}

    /* Appear button (left edge, 3/4 down) */
    .edge-left{
      position:fixed; left:10px; top:75vh; transform:translateY(-50%); z-index:9999;
      padding:12px 16px; border-radius:14px; cursor:pointer;
      background:#07120e; color:#eafff4; border:1px solid #0f261e;
      box-shadow:0 0 12px var(--glow), 0 0 24px var(--glow2); text-shadow:0 0 6px var(--glow), 0 0 12px var(--glow2);
    }
    .edge-left.pulse{animation:gpulse 1.4s ease-in-out infinite}
    @keyframes gpulse{0%,100%{box-shadow:0 0 12px var(--glow),0 0 24px var(--glow2)}50%{box-shadow:0 0 18px var(--glow),0 0 40px var(--glow2)}}

    /* Panel shell */
    #decks-panel{transition:opacity .25s ease, transform .25s ease}
    #decks-panel[hidden]{opacity:0; transform:translateX(-8px); pointer-events:none}
    .wrap{max-width:min(var(--wrapW),98vw); margin:16px auto; padding:10px}

    .panel{background:linear-gradient(180deg,#07100d,#091613); border:1px solid #0f1a18; border-radius:14px; padding:12px; box-shadow:0 0 0 1px #0a1714, 0 0 25px rgba(53,255,154,.12)}
    .row{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap}
    .center{justify-content:center}
    .muted{color:var(--muted); font-size:12px}
    .h{font-weight:700; letter-spacing:.3px}
    .glowTxt{text-shadow:0 0 8px var(--glow), 0 0 18px var(--glow2)}

    .btn{border:1px solid #0f261e; background:#07120e; color:var(--fg); padding:10px 14px; border-radius:12px; cursor:pointer; box-shadow:0 0 0 1px #0a1714, 0 0 18px rgba(28,255,136,.15) inset}
    .btn.hot{background:radial-gradient(100% 100% at 50% 0%, #0e2a1f, #0a1714); border-color:#124f3b}
    .btn.rec{background:#1a0b0e; border-color:#2b0f16; box-shadow:0 0 12px rgba(255,77,109,.35) inset, 0 0 24px rgba(255,77,109,.18)}

    input[type=range], input[type=file]{appearance:none;-webkit-appearance:none;background:#07120e;color:var(--fg);border:1px solid #103127;border-radius:10px;padding:8px 10px;box-shadow:0 0 0 1px #0a1714 inset, 0 0 16px rgba(53,255,154,.12) inset;font-size:14px;width:var(--ctlW)}
    input[type=range]{height:28px}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:10px;background:var(--glow);box-shadow:0 0 8px var(--glow),0 0 18px var(--glow2)}
    input[type=range]::-moz-range-thumb{width:18px;height:18px;border:none;border-radius:10px;background:var(--glow);box-shadow:0 0 8px var(--glow),0 0 18px var(--glow2)}
    .tag{font-size:12px; padding:6px 8px; border:1px solid #0f261e; border-radius:10px; background:#07120e; color:var(--muted)}

    .topGrid{display:grid; grid-template-columns:1fr auto 1fr; gap:var(--gap); align-items:center}
    @media (max-width:980px){ .topGrid{grid-template-columns:1fr; justify-items:center} :root{--ctlW:180px} }

    .decksGrid{display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); align-items:start}
    @media (max-width:980px){ .decksGrid{grid-template-columns:1fr} }

    .deck{display:flex; flex-direction:column; gap:12px}
    .wavebox{position:relative; background:#05100c; border:1px solid #0e241d; border-radius:12px; padding:8px}
    canvas.wave{width:100%; height:var(--waveH); display:block; border-radius:8px; background:linear-gradient(180deg,#04110c,#071a14 60%, #03100b); box-shadow:inset 0 0 25px rgba(53,255,154,.08)}
    .playhead{position:absolute; top:8px; bottom:8px; width:2px; left:8px; background:var(--accent); box-shadow:0 0 10px var(--accent)}

    .meters{display:flex; gap:8px; align-items:center}
    .meter{width:8px; height:42px; background:#0b1714; border:1px solid #103127; border-radius:4px; position:relative; overflow:hidden}
    .meter>.fill{position:absolute; bottom:0; left:0; width:100%; height:30%; background:linear-gradient(180deg,var(--glow2),var(--glow)); box-shadow:0 0 12px var(--glow)}
  </style>
</head>
<body>

  <!-- Appear button -->
  <button id="btn-appear" class="edge-left">‚ñ≤ Appear</button>

  <!-- Main decks panel (hidden initially) -->
  <div id="decks-panel" hidden>
    <div class="wrap" id="ultraWrap">

      <!-- Top bar -->
      <div class="panel topGrid">
        <!-- Left: Deck A -->
        <div class="row center">
          <button id="playA" class="btn hot">‚ñ∂ A</button>
          <button id="pauseA" class="btn">‚ùö‚ùö</button>
          <label class="tag">Vol A <input id="volA" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <label class="tag">Load A <input id="fileA" type="file" accept="audio/*"></label>
        </div>
        <!-- Middle: Hide + Master + meters -->
        <div class="row center">
          <button id="btn-hide" class="btn">‚úñ Hide</button>
          <label class="tag">Master <input id="masterVol" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <div class="meters">
            <div class="meter"><div id="mA" class="fill" style="height:10%"></div></div>
            <div class="meter"><div id="mB" class="fill" style="height:10%"></div></div>
          </div>
        </div>
        <!-- Right: Deck B -->
        <div class="row center">
          <label class="tag">Load B <input id="fileB" type="file" accept="audio/*"></label>
          <label class="tag">Vol B <input id="volB" type="range" min="0" max="1.5" step="0.01" value="1"></label>
          <button id="pauseB" class="btn">‚ùö‚ùö</button>
          <button id="playB" class="btn hot">‚ñ∂ B</button>
        </div>
      </div>

      <!-- Decks -->
      <div class="decksGrid">
        <section class="panel deck" id="deckA">
          <div class="h glowTxt" style="text-align:center">Deck A</div>
          <div class="wavebox">
            <canvas id="waveA" class="wave"></canvas>
            <div id="headA" class="playhead"></div>
          </div>
          <div class="row center">
            <button id="cueSetA" class="btn">Set Cue</button>
            <button id="cueGoA" class="btn">Cue ‚ñ∂</button>
            <label class="tag">Seek A <input id="seekA" type="range" min="0" max="1" step="0.001" value="0"></label>
          </div>
        </section>

        <section class="panel deck" id="deckB">
          <div class="h glowTxt" style="text-align:center">Deck B</div>
          <div class="wavebox">
            <canvas id="waveB" class="wave"></canvas>
            <div id="headB" class="playhead"></div>
          </div>
          <div class="row center">
            <button id="cueSetB" class="btn">Set Cue</button>
            <button id="cueGoB" class="btn">Cue ‚ñ∂</button>
            <label class="tag">Seek B <input id="seekB" type="range" min="0" max="1" step="0.001" value="0"></label>
          </div>
        </section>
      </div>

      <!-- Mixer -->
      <div class="panel">
        <div class="row center">
          <span class="muted">A</span>
          <input id="xfade" type="range" min="0" max="1" step="0.001" value="0" style="width:min(560px, 90vw)">
          <span class="muted">B</span>
        </div>
      </div>

      <!-- Recorder -->
      <div class="panel">
        <div class="row center">
          <button id="recBtn" class="btn rec">‚óè Record</button>
          <span id="recLamp" style="width:14px;height:14px;border-radius:999px;background:#193b30; box-shadow:0 0 0 2px #0b1a14 inset; display:inline-block"></span>
          <button id="dlBtn" class="btn" disabled>Download Mix</button>
          <span class="muted">Format: audio/webm</span>
        </div>
      </div>

      <p class="muted" style="text-align:center">Drag waveforms to seek. Crossfader is equal-power. Everything glows green üå±</p>
    </div>
  </div>

  <script>
    // Prevent mobile copy/long-press UI
    addEventListener('contextmenu', e=> e.preventDefault(), {passive:false});
    addEventListener('selectstart', e=> e.preventDefault(), {passive:false});
    addEventListener('gesturestart', e=> e.preventDefault(), {passive:false});

    // Appear / Hide
    const panel = document.getElementById('decks-panel');
    const appearBtn = document.getElementById('btn-appear');
    const hideBtn = document.getElementById('btn-hide');
    appearBtn.addEventListener('click', ()=>{ panel.hidden=false; appearBtn.classList.remove('pulse'); });
    hideBtn.addEventListener('click', ()=>{ panel.hidden=true;  appearBtn.classList.add('pulse'); });
    panel.hidden = true; appearBtn.classList.add('pulse');

    // Audio
    let ctx, master, recDest, mediaRec, chunks=[], isRec=false;
    function makeDeck(){ return {fileEl:null,playBtn:null,pauseBtn:null,volEl:null,seekEl:null,waveCan:null,waveCtx:null,headEl:null,meterFill:null,buffer:null,src:null,gain:null,xGain:null,analyser:null,isPlaying:false,startTime:0,offset:0,cue:0}; }
    const deckA = makeDeck(), deckB = makeDeck();

    function initAudio(){
      if (ctx) return;
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value = parseFloat(document.getElementById('masterVol').value||1);
      recDest = ctx.createMediaStreamDestination(); master.connect(recDest); master.connect(ctx.destination);
      [deckA, deckB].forEach(d=>{ d.gain=ctx.createGain(); d.gain.gain.value=1; d.xGain=ctx.createGain(); d.xGain.gain.value=1; d.analyser=ctx.createAnalyser(); d.analyser.fftSize=2048; d.gain.connect(d.xGain).connect(d.analyser).connect(master); });
      applyCrossfade(parseFloat(document.getElementById('xfade').value||0));
    }

    function loadFileToDeck(file, deck){
      if(!file) return; initAudio();
      const fr=new FileReader();
      fr.onload = async e=>{
        try{
          const buf = await ctx.decodeAudioData(e.target.result);
          deck.buffer=buf; deck.offset=0; deck.cue=0; deck.seekEl.value=0;
          drawWave(deck); stopDeck(deck); prepareSource(deck);
        }catch(err){ console.error(err); alert('Could not decode that audio file.'); }
      };
      fr.readAsArrayBuffer(file);
    }

    function prepareSource(deck){ if(!deck.buffer) return; if(deck.src){try{deck.src.disconnect();}catch{} deck.src=null;} const s=ctx.createBufferSource(); s.buffer=deck.buffer; s.connect(deck.gain); deck.src=s; }
    function playDeck(deck){ if(!deck.buffer) return; initAudio(); if(deck.isPlaying) return; prepareSource(deck); deck.startTime=ctx.currentTime-deck.offset; deck.src.start(0,deck.offset); deck.isPlaying=true; deck.src.onended=()=>{ if(deck.isPlaying){ deck.isPlaying=false; deck.offset=0; deck.seekEl.value=0; prepareSource(deck);} }; }
    function pauseDeck(deck){ if(!deck.isPlaying) return; try{deck.src.stop();}catch{} deck.offset=Math.min(deck.buffer.duration, Math.max(0, ctx.currentTime-deck.startTime)); deck.isPlaying=false; prepareSource(deck); }
    function stopDeck(deck){ if(deck.isPlaying){try{deck.src.stop();}catch{}} deck.isPlaying=false; deck.offset=0; deck.seekEl.value=0; prepareSource(deck); }

    function setSeek(deck, norm){ if(!deck.buffer) return; const pos=norm*deck.buffer.duration; const was=deck.isPlaying; if(was) pauseDeck(deck); deck.offset=pos; deck.seekEl.value=norm; if(was) playDeck(deck); drawHeads(); }
    function setCue(deck){ if(deck.buffer) deck.cue = deck.offset; }
    function goCue(deck){ if(!deck.buffer) return; const was=deck.isPlaying; if(was) pauseDeck(deck); deck.offset=Math.min(deck.buffer.duration, Math.max(0, deck.cue)); deck.seekEl.value=deck.offset/deck.buffer.duration; if(was) playDeck(deck); }

    function applyCrossfade(x){ const gA=Math.cos(0.5*Math.PI*x); const gB=Math.cos(0.5*Math.PI*(1-x)); deckA.xGain.gain.value=gA*gA; deckB.xGain.gain.value=gB*gB; }
    function analyserLevel(an){ const arr=new Uint8Array(an.frequencyBinCount); an.getByteTimeDomainData(arr); let sum=0; for(let i=0;i<arr.length;i++){const v=(arr[i]-128)/128; sum+=v*v;} return Math.min(1, Math.sqrt(sum/arr.length)*1.8); }

    function drawWave(deck){
      const cvs=deck.waveCan, c=deck.waveCtx;
      const W=cvs.width=Math.floor(cvs.clientWidth*devicePixelRatio);
      const H=cvs.height=Math.floor(cvs.clientHeight*devicePixelRatio);
      c.clearRect(0,0,W,H);
      if(!deck.buffer){ c.fillStyle='rgba(28,255,136,.06)'; c.fillRect(0,0,W,H); return; }
      const ch=deck.buffer.getChannelData(0), samples=Math.max(1,W), block=Math.max(1,Math.floor(ch.length/samples));
      c.lineWidth=Math.max(1,Math.floor(1.2*devicePixelRatio)); c.strokeStyle='#35ff9a'; c.shadowColor='#35ff9a'; c.shadowBlur=10;
      c.beginPath();
      for(let x=0;x<samples;x++){ const s=x*block, e=Math.min(ch.length,s+block); let mn=1e9,mx=-1e9; for(let i=s;i<e;i++){const v=ch[i]; if(v<mn)mn=v; if(v>mx)mx=v;} const y1=(1-mn)*0.5*H, y2=(1-mx)*0.5*H; c.moveTo(x,y1); c.lineTo(x,y2); }
      c.stroke(); c.shadowBlur=0; c.strokeStyle='rgba(124,255,200,.18)'; c.beginPath(); c.moveTo(0,H/2); c.lineTo(W,H/2); c.stroke();
    }
    function drawHeads(){
      [[deckA,'headA'],[deckB,'headB']].forEach(([d,id])=>{
        const head=d.headEl, wave=d.waveCan;
        if(d.buffer){ const dur=d.buffer.duration, off=d.isPlaying?(ctx.currentTime-d.startTime):d.offset; const norm=Math.min(1,Math.max(0,off/dur)); const px=8+norm*(wave.clientWidth-16); head.style.left=px+'px'; }
        else head.style.left='8px';
      });
    }

    function $(id){return document.getElementById(id)}
    function bindDeck(deck, ids){
      deck.playBtn=$$(ids.play); deck.pauseBtn=$$(ids.pause); deck.fileEl=$$(ids.file);
      deck.volEl=$$(ids.vol); deck.seekEl=$$(ids.seek); deck.waveCan=$$(ids.wave);
      deck.waveCtx=deck.waveCan.getContext('2d'); deck.headEl=$$(ids.head); deck.meterFill=$$(ids.meter);

      deck.fileEl.addEventListener('change', e=> loadFileToDeck(e.target.files[0], deck));
      deck.playBtn.addEventListener('click', ()=> playDeck(deck));
      deck.pauseBtn.addEventListener('click', ()=> pauseDeck(deck));
      deck.volEl.addEventListener('input', ()=> { initAudio(); deck.gain.gain.value=parseFloat(deck.volEl.value||1); });
      deck.seekEl.addEventListener('input', ()=> setSeek(deck, parseFloat(deck.seekEl.value)));

      let dragging=false;
      function normFromEvent(ev){ const r=deck.waveCan.getBoundingClientRect(); const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-r.left; return Math.min(1,Math.max(0,x/r.width)); }
      deck.waveCan.addEventListener('pointerdown', e=>{dragging=true; setSeek(deck, normFromEvent(e)); deck.waveCan.setPointerCapture(e.pointerId);});
      deck.waveCan.addEventListener('pointermove', e=>{if(dragging) setSeek(deck, normFromEvent(e));});
      deck.waveCan.addEventListener('pointerup', e=>{dragging=false; try{deck.waveCan.releasePointerCapture(e.pointerId);}catch{}});
      deck.waveCan.addEventListener('pointerleave', ()=>{dragging=false;});

      new ResizeObserver(()=> drawWave(deck)).observe(deck.waveCan);
    }
    function $$(id){return document.getElementById(id)}

    bindDeck(deckA,{play:'playA',pause:'pauseA',file:'fileA',vol:'volA',seek:'seekA',wave:'waveA',head:'headA',meter:'mA'});
    bindDeck(deckB,{play:'playB',pause:'pauseB',file:'fileB',vol:'volB',seek:'seekB',wave:'waveB',head:'headB',meter:'mB'});

    $('cueSetA').addEventListener('click', ()=> setCue(deckA));
    $('cueGoA').addEventListener('click',  ()=> goCue(deckA));
    $('cueSetB').addEventListener('click', ()=> setCue(deckB));
    $('cueGoB').addEventListener('click',  ()=> goCue(deckB));

    $('xfade').addEventListener('input', e=> applyCrossfade(parseFloat(e.target.value)));
    $('masterVol').addEventListener('input', e=> { initAudio(); master.gain.value=parseFloat(e.target.value||1); });

    const recBtn=$('recBtn'), dlBtn=$('dlBtn'), recLamp=$('recLamp');
    recBtn.addEventListener('click', ()=>{
      initAudio();
      if(!mediaRec){
        const stream=recDest.stream;
        try{ mediaRec=new MediaRecorder(stream,{mimeType:'audio/webm'});}catch(e){ mediaRec=new MediaRecorder(stream); }
        mediaRec.ondataavailable=e=>{ if(e.data?.size) chunks.push(e.data); };
        mediaRec.onstop=()=>{ const blob=new Blob(chunks,{type:chunks[0]?.type||'audio/webm'}); chunks=[]; const url=URL.createObjectURL(blob); dlBtn.disabled=false; dlBtn._url=url; };
      }
      if(!isRec){ chunks=[]; mediaRec.start(150); isRec=true; recLamp.style.background='#ff445f'; recLamp.style.boxShadow='0 0 10px #ff445f, 0 0 22px rgba(255,68,95,.55)'; recBtn.textContent='‚ñ† Stop'; }
      else{ mediaRec.stop(); isRec=false; recLamp.style.background='#193b30'; recLamp.style.boxShadow='0 0 0 2px #0b1a14 inset'; recBtn.textContent='‚óè Record'; }
    });
    dlBtn.addEventListener('click', e=>{ if(!dlBtn._url){e.preventDefault();return;} const a=document.createElement('a'); a.href=dlBtn._url; a.download='UltraMix.webm'; document.body.appendChild(a); a.click(); a.remove(); });

    function tick(){
      if(ctx){
        [deckA,deckB].forEach(d=>{
          if(d.isPlaying){
            const newOff=ctx.currentTime-d.startTime;
            if(newOff>=d.buffer.duration){ d.isPlaying=false; d.offset=0; d.seekEl.value=0; prepareSource(d); }
          }
          if(d.analyser && d.meterFill){ d.meterFill.style.height=Math.round(analyserLevel(d.analyser)*100)+'%'; }
        });
        drawHeads();
      }
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>
<!-- === DONATE PANEL WITH BOTTOM REAPPEAR ================ -->
<style>
  .donate-wrap{
    position:fixed;top:20px;right:20px;z-index:1000;
    display:flex;flex-direction:column;align-items:flex-end;gap:10px;
    font-family:'Segoe UI',system-ui,sans-serif;
  }
  .donate-card{
    max-width:min(500px,95vw);
    border-radius:20px;padding:18px 20px;
    background:linear-gradient(180deg,rgba(20,28,36,.92),rgba(12,18,28,.85));
    border:2px solid #35ff8a;
    box-shadow:0 0 30px #35ff8a88,0 0 60px #7cf6ff55;
    color:#eaffef;text-align:left;
    animation:floaty 6s ease-in-out infinite;
  }
  @keyframes floaty{0%,100%{transform:translateY(0)}50%{transform:translateY(-4px)}}

  .donate-title{
    font-size:20px;font-weight:900;margin-bottom:10px;
    text-shadow:0 0 12px #7cf6ff,0 0 24px #35ff8a;
  }
  .donate-line{font-size:15px;margin-bottom:14px;line-height:1.4}
  .donate-line em{color:#ffe66d;font-style:normal;font-weight:700}

  .donate-btns{display:flex;flex-wrap:wrap;gap:10px}
  .don-btn{
    all:unset;cursor:pointer;padding:10px 18px;border-radius:14px;font-weight:800;
    font-size:15px;display:inline-flex;align-items:center;gap:8px;
    background:linear-gradient(180deg,#b9ffd8,#54f7a9);color:#0a1f14;
    box-shadow:0 0 20px #35ff8a88,inset 0 0 0 2px rgba(0,0,0,.2);
  }
  .don-btn--blue{
    background:linear-gradient(180deg,#a9e6ff,#3393ff);color:#fff;
    box-shadow:0 0 20px #7cf6ff88,inset 0 0 0 2px rgba(0,0,0,.2);
  }
  .don-row{display:flex;justify-content:flex-end;margin-top:10px}
  .don-mini{
    all:unset;cursor:pointer;padding:6px 12px;border-radius:10px;font-size:13px;
    font-weight:700;color:#fff;
    background:linear-gradient(180deg,#ff8ba7,#ff3355);
    box-shadow:0 0 12px #ff6db488;
  }

  /* Reappear button fixed at bottom center */
  #donReappear{
    display:none;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);
    cursor:pointer;padding:12px 18px;border-radius:16px;font-weight:800;
    background:linear-gradient(180deg,#ffe66d,#ff9e33);
    box-shadow:0 0 20px #ffae5588;
    color:#1a1205;font-size:15px;z-index:1001;
    animation:pulse 2s infinite;
  }
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}
</style>

<div class="donate-wrap">
  <div class="donate-card" id="donCard">
    <div class="donate-title">‚ú® We Help Kids Create ‚ú®</div>
    <div class="donate-line">
      Together we turn <em>what if</em> into <em>we did</em> ‚Äî
      giving kids in need the tools to <em>draw, dream, and discover</em>.
      Your gift fuels art, music, and safe spaces for their imagination. üåà
    </div>
    <div class="donate-btns">
      <a class="don-btn" href="https://cash.app/$lightwell333" target="_blank">üíö CashApp</a>
      <a class="don-btn don-btn--blue" href="https://paypal.me/lightwell333" target="_blank">üíô PayPal</a>
    </div>
    <div class="don-row">
      <button class="don-mini" id="donClose">Close</button>
    </div>
  </div>
</div>

<button id="donReappear">üí´ Reappear Donate</button>

<script>
(()=> {
  const card=document.getElementById('donCard');
  const close=document.getElementById('donClose');
  const reappear=document.getElementById('donReappear');

  close.addEventListener('click', ()=>{
    card.style.display='none';
    reappear.style.display='inline-block';
  });
  reappear.addEventListener('click', ()=>{
    card.style.display='block';
    reappear.style.display='none';
  });
})();
</script>
<!-- === /DONATE PANEL ================================== --><!-- ============== PSYFORGE PSYTRANCE COVER ============== -->
<style>
  #psyforgeCover{
    position:fixed; inset:0; z-index:999999; display:grid; place-items:center;
    overflow:hidden; font-family:"Segoe UI",system-ui,sans-serif; color:#eaffef;
    opacity:1; transition:opacity .45s ease; pointer-events:auto;
  }
  #psyforgeCover.hidden{ opacity:0; pointer-events:none; }

  /* Background kaleidoscope canvas */
  #coverKale{
    position:absolute; inset:0; width:100%; height:100%; display:block; background:#000;
  }

  /* Card with title & text */
  #psyforgeCover .card{
    position:relative; z-index:1; text-align:center;
    padding:26px 32px; border-radius:24px; max-width:min(720px,92vw);
    background:linear-gradient(180deg, rgba(10,18,26,.82), rgba(10,16,24,.68));
    border:1px solid rgba(124,246,255,.4);
    box-shadow:0 0 36px rgba(124,246,255,.28), inset 0 0 22px rgba(0,0,0,.4);
    backdrop-filter:blur(8px);
  }
  .logo{
    font-weight:900; letter-spacing:.06em; text-transform:uppercase;
    font-size:clamp(36px,7.5vw,78px); line-height:1.02; margin:0 0 8px;
    background:linear-gradient(90deg,#7cf6ff,#35ff8a,#ffe66d,#ff6db4,#7cf6ff);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 0 18px rgba(124,246,255,.5), 0 0 36px rgba(53,255,138,.35);
    animation:hueshift 12s linear infinite;
  }
  @keyframes hueshift{to{filter:hue-rotate(360deg)}}
  .tag{font-weight:800; opacity:.95; margin-bottom:12px}
  .poem{font-size:clamp(14px,2.6vw,18px); line-height:1.45; color:#d8ffee; margin:10px 0 16px}
  .hint{font-weight:900; letter-spacing:.08em; color:#b9ffd8; text-shadow:0 0 12px #35ff8a66}

  /* Enter button */
  .enterBtn{
    margin-top:14px; all:unset; cursor:pointer; padding:12px 18px; border-radius:14px;
    font-weight:900; font-size:15px; color:#06130d;
    background:linear-gradient(180deg,#b9ffd8,#54f7a9);
    border:1px solid rgba(53,255,138,.6);
    box-shadow:0 0 20px #35ff8a88, inset 0 0 0 1px rgba(0,0,0,.22);
  }
  .enterBtn:hover{ filter:brightness(1.06) }

  /* Subtle reappear button */
  #coverReappear{
    position:fixed; right:12px; bottom:14px; z-index:999998;
    display:none; padding:6px 10px; border-radius:10px; cursor:pointer;
    font-weight:700; font-size:11px; color:#06130d;
    background:linear-gradient(180deg,#a9e6ff,#3393ff);
    border:1px solid rgba(124,246,255,.5);
    box-shadow:0 0 12px #7cf6ff66;
    opacity:.8; transition:opacity .25s ease;
  }
  #coverReappear:hover{ opacity:1 }
</style>

<div id="psyforgeCover" role="dialog" aria-label="PsyForge Cover">
  <canvas id="coverKale"></canvas>
  <div class="card">
    <div class="logo">PSYFORGE</div>
    <div class="tag">The Psychedelic Visual Mixer</div>
    <div class="poem">
      Twist sound into light, bend colors into rhythm, and watch imagination dance.<br/>
      A playground of <strong>kaleidoscopes, mirrors, and motion</strong> ‚Äî made for dreamers,
      artists, and kids in need.
    </div>
    <div class="hint">Press ENTER to begin</div>
    <button class="enterBtn" id="coverEnter">ENTER PSYFORGE</button>
  </div>
</div>

<button id="coverReappear" title="Show Cover">üí´ Reappear</button>

<script>
(() => {
  const cover  = document.getElementById('psyforgeCover');
  const enter  = document.getElementById('coverEnter');
  const reBtn  = document.getElementById('coverReappear');
  const kale   = document.getElementById('coverKale');
  const ctx = kale.getContext('2d');

  let visible = true;
  function showCover(){
    if(visible) return;
    visible = true;
    cover.classList.remove('hidden');
    cover.setAttribute('aria-hidden','false');
    reBtn.style.display = 'none';
  }
  function hideCover(){
    if(!visible) return;
    visible = false;
    cover.classList.add('hidden');
    cover.setAttribute('aria-hidden','true');
    setTimeout(()=>{ if(!visible) reBtn.style.display='inline-block'; }, 300);
  }

  enter.addEventListener('click', hideCover);
  reBtn.addEventListener('click', showCover);

  window.PsyforgeCover = { show: showCover, hide: hideCover };

  // Canvas plasma / psytrance loop
  function resize(){
    kale.width = window.innerWidth;
    kale.height = window.innerHeight;
  }
  window.addEventListener('resize', resize); resize();

  let t = 0;
  function loop(){
    const w = kale.width, h = kale.height;
    const img = ctx.createImageData(w,h);
    const d = img.data;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const v = Math.sin(x/45 + t/20) + Math.cos(y/35 - t/30) + Math.sin((x+y)/60 + t/15);
        const hue = (v*120 + t*4) % 360;
        const sat = 100;
        const light = 50 + 25*Math.sin((x+y+t)/80);
        const [r,g,b] = hslToRgb(hue/360, sat/100, light/100);
        d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
    t++;
    requestAnimationFrame(loop);
  }
  loop();

  // HSL ‚Üí RGB helper
  function hslToRgb(h,s,l){
    let r,g,b;
    if(s==0){r=g=b=l;}
    else{
      const hue2rgb=(p,q,t)=>{
        if(t<0)t+=1;if(t>1)t-=1;
        if(t<1/6)return p+(q-p)*6*t;
        if(t<1/2)return q;
        if(t<2/3)return p+(q-p)*(2/3-t)*6;
        return p;
      };
      const q=l<.5?l*(1+s):l+s-l*s;
      const p=2*l-q;
      r=hue2rgb(p,q,h+1/3);
      g=hue2rgb(p,q,h);
      b=hue2rgb(p,q,h-1/3);
    }
    return [r*255,g*255,b*255];
  }
})();
</script>
<!-- ================= /PSYFORGE COVER =================== --><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Kaleidoscope Background + Global Slots (with Capture + Gestures)</title>
<style>
  :root{ --fg:#eaf3ff; --muted:#9fb0c9; --line:#2a3146; }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden}

  /* ===== Kaleidoscope canvas as permanent background ===== */
  #kaleido{
    position:fixed; inset:0; width:100vw; height:100vh; display:block;
    z-index:0; background:#000; touch-action:none; cursor:grab;
  }

  /* ===== Kaleidoscope control panel (no appear button) ===== */
  #kbar{
    position:fixed; left:50%; top:12px; transform:translateX(-50%);
    display:grid; gap:10px; grid-template-columns:repeat(4,minmax(260px,1fr)); /* +1 column for Capture */
    max-width:96vw; max-height:84vh; overflow:auto; padding:12px;
    background:linear-gradient(180deg,rgba(16,18,26,.78),rgba(12,14,20,.65));
    border:1px solid var(--line); border-radius:14px; backdrop-filter:blur(10px);
    z-index:20;
  }
  @media (max-width:1100px){ #kbar{grid-template-columns:repeat(2,minmax(260px,1fr));} }
  @media (max-width:760px){ #kbar{grid-template-columns:1fr;} }

  .card{border:1px solid var(--line); border-radius:12px; background:rgba(8,10,16,.55); padding:10px}
  .title{font-weight:800;margin:0 0 8px}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  label{display:grid; gap:6px; font-size:13px}
  input[type="range"]{width:100%}

  /* Buttons */
  #hidePanel{
    position:fixed; right:12px; top:12px; z-index:30;
    border:none; border-radius:12px; padding:8px 12px; cursor:pointer; font-weight:800; color:#0a1f14;
    background:linear-gradient(180deg,#B9FFD8,#54F7A9);
    box-shadow:0 0 18px 6px rgba(108,255,178,.45),inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .mintbtn{
    border:none;border-radius:12px;padding:6px 12px;font-weight:800;cursor:pointer;font-size:14px;
    box-shadow:0 0 14px 5px rgba(108,255,178,.35), inset 0 0 0 1px rgba(0,0,0,.15)
  }
  #kSnap{color:#0a1f14;background:linear-gradient(180deg,#B9FFD8,#54F7A9)}
  #kRecStart{color:#fff;background:linear-gradient(180deg,#ff8ba7,#ff3355)}
  #kRecStop{color:#fff;background:linear-gradient(180deg,#9ab6ff,#3344ff)}
  #kRecStop[disabled]{opacity:.5;cursor:not-allowed;box-shadow:none}

  /* ===== Global edge ‚Äúplaces‚Äù for insert appear buttons ===== */
  .lane{position:fixed;display:grid;gap:8px;pointer-events:none;z-index:50;opacity:.25}
  #lane-top,#lane-bottom{left:6vw;right:6vw;grid-template-columns:repeat(6,1fr)}
  #lane-top{top:10px} #lane-bottom{bottom:10px}
  #lane-left,#lane-right{top:10vh;bottom:10vh;grid-template-rows:repeat(8,1fr)}
  #lane-left{left:10px} #lane-right{right:10px}
  .slot{min-width:56px;min-height:56px;border-radius:10px;display:flex;align-items:center;justify-content:center}
  .appear{
    pointer-events:auto;border:none;border-radius:12px;padding:10px 14px;
    font-size:16px;font-weight:800;display:inline-flex;align-items:center;gap:8px;cursor:pointer;
    color:#0a1f14;background:linear-gradient(180deg,#B9FFD8,#54F7A9);
    box-shadow:0 0 18px 6px rgba(108,255,178,.45), inset 0 0 0 1px rgba(0,0,0,.15);
  }

  /* Example insert overlay should sit on top of kaleido (z-index > 0) */
  .insert-overlay{ position:fixed; inset:0; display:none; place-items:center; z-index:60; }
</style>
</head>
<body>

<!-- Kaleidoscope always-on background -->
<canvas id="kaleido"></canvas>

<!-- Kaleidoscope controls (no appear button; just a hide/show) -->
<button id="hidePanel">Hide Controls</button>
<div id="kbar" aria-label="Kaleidoscope Controls">
  <div class="card">
    <div class="title">Mixer</div>
    <label>Crossfade A ‚Üî B <input id="mix" type="range" min="0" max="1" step="0.001" value="0.5"></label>
    <div class="row">
      <button id="modeK" class="btn" style="border:1px solid var(--line);border-radius:10px;padding:6px 10px;background:transparent">Kaleidoscope</button>
      <button id="modeM" class="btn" style="border:1px solid var(--line);border-radius:10px;padding:6px 10px;background:transparent">Mirror</button>
    </div>
    <label>Wedges (2‚Äì16) <input id="wedges" type="range" min="2" max="16" step="1" value="8"></label>
  </div>

  <div class="card">
    <div class="title">Transform</div>
    <label>Zoom <input id="zoom" type="range" min="0.2" max="6" step="0.001" value="1.0"></label>
    <label>Rotate (scene) <input id="rot" type="range" min="-3.1416" max="3.1416" step="0.0005" value="0"></label>
    <label>Pan X <input id="panx" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Pan Y <input id="pany" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <!-- SLOW SPIN: was -2..2 step .01. Now ultra-fine. -->
    <label>Image Spin (rev/s) <input id="spinHz" type="range" min="-0.05" max="0.05" step="0.0001" value="0"></label>
  </div>

  <div class="card">
    <div class="title">Ripple</div>
    <label>Amount <input id="rAmp" type="range" min="0" max="0.6" step="0.001" value="0.20"></label>
    <label>Frequency <input id="rFreq" type="range" min="0.5" max="12" step="0.01" value="6"></label>
    <label>Speed <input id="rSpeed" type="range" min="0" max="6" step="0.01" value="1.5"></label>
  </div>

  <div class="card">
    <div class="title">Decks</div>
    <label>Deck A <input id="pickA" type="file" accept="image/*,video/*"></label>
    <label>Deck B <input id="pickB" type="file" accept="image/*,video/*"></label>
  </div>

  <!-- NEW: Capture -->
  <div class="card">
    <div class="title">Capture</div>
    <div class="row">
      <button id="kSnap" class="mintbtn">üì∏ Snapshot</button>
      <button id="kRecStart" class="mintbtn">‚è∫ Start Rec</button>
      <button id="kRecStop" class="mintbtn" disabled>‚èπ Stop</button>
    </div>
    <div style="font-size:12px;opacity:.8;margin-top:6px">Snapshot needs same-origin/CORS. Recording saves a WEBM of the canvas.</div>
  </div>
</div>

<!-- Global edge ‚Äúplaces‚Äù for insert buttons -->
<div id="lane-top" class="lane"></div>
<div id="lane-bottom" class="lane"></div>
<div id="lane-left" class="lane"></div>
<div id="lane-right" class="lane"></div>

<script>
/* ================= Kaleidoscope background engine ================= */
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('kaleido');
  const UI = {
    mix:$('mix'), wedges:$('wedges'), zoom:$('zoom'), rot:$('rot'),
    panx:$('panx'), pany:$('pany'), rAmp:$('rAmp'), rFreq:$('rFreq'), rSpeed:$('rSpeed'),
    modeK:$('modeK'), modeM:$('modeM'), pickA:$('pickA'), pickB:$('pickB'), spinHz:$('spinHz')
  };
  const state = {
    mix:+UI.mix.value, wedges:+UI.wedges.value, zoom:+UI.zoom.value, rot:+UI.rot.value,
    panx:+UI.panx.value, pany:+UI.pany.value, rAmp:+UI.rAmp.value, rFreq:+UI.rFreq.value, rSpeed:+UI.rSpeed.value,
    spinHz:+UI.spinHz.value, mode:0
  };
  ['mix','wedges','zoom','rot','panx','pany','rAmp','rFreq','rSpeed','spinHz']
    .forEach(k=>UI[k].addEventListener('input', ()=> state[k]=+UI[k].value));
  UI.modeK.onclick = ()=>{ state.mode=0; };
  UI.modeM.onclick = ()=>{ state.mode=1; };

  function fit(){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr);
    if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; }
  }
  addEventListener('resize', fit);

  const deckA = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  const deckB = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  deckA.ctx = deckA.cvs.getContext('2d'); deckB.ctx = deckB.cvs.getContext('2d');

  function loadTo(deck, file){
    if(file.type.startsWith('video')){
      const v=document.createElement('video'); v.muted=true; v.loop=true; v.playsInline=true; v.autoplay=true;
      v.onloadeddata=()=>{ v.play().catch(()=>{}); deck.vid=v; deck.img=null; };
      v.src=URL.createObjectURL(file);
    }else{
      const img=new Image();
      img.onload=()=>{ deck.img=img; deck.vid=null; };
      img.src=URL.createObjectURL(file);
    }
  }
  UI.pickA.onchange = e => { const f=e.target.files[0]; if(f) loadTo(deckA,f); e.target.value=''; };
  UI.pickB.onchange = e => { const f=e.target.files[0]; if(f) loadTo(deckB,f); e.target.value=''; };

  // Try WebGL2 ‚Üí WebGL ‚Üí Canvas2D
  function tryGL(ver){ try{ return cv.getContext(ver,{preserveDrawingBuffer:true,antialias:true}); }catch{return null;} }
  let gl = tryGL('webgl2') || tryGL('webgl');
  let renderer=null, t0=performance.now();

  if(gl){
    const vs = `
      attribute vec2 aPos; varying vec2 vUv;
      void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.,1.); }
    `;
    const fs = `
      precision highp float; varying vec2 vUv;
      uniform sampler2D texA, texB; uniform float mixAB;
      uniform vec2 resolution; uniform float time;
      uniform int mode; uniform float wedges; uniform float zoom, rot; uniform vec2 pan;
      uniform float rAmp, rFreq, rSpeed; uniform float imgSpin;
      mat2 R(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }
      vec2 rotAround(vec2 uv, float a){ vec2 d=uv-0.5; d=R(a)*d; return d+0.5; }
      vec2 userUV(vec2 p){
        vec2 q = R(rot)*p;
        float r = length(q);
        float wave = sin(r*rFreq - time*rSpeed);
        q *= (1.0 + wave * rAmp);
        q *= zoom; q += pan;
        return q*0.5 + 0.5;
      }
      vec3 sampleMix(vec2 uv){
        vec2 suv = rotAround(uv, imgSpin);
        vec4 a=texture2D(texA,suv), b=texture2D(texB,suv);
        return mix(a,b,clamp(mixAB,0.0,1.0)).rgb;
      }
      vec3 kaleido(){
        vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
        float ang=atan(n.y,n.x), r=length(n);
        float sector = 6.28318530718 / max(2.0, wedges);
        float a = mod(ang, sector); if(a>0.5*sector) a = sector - a;
        vec2 dir = vec2(cos(a), sin(a));
        return sampleMix(userUV(r*dir));
      }
      vec3 mirrorFX(){
        vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
        vec2 p = vec2(abs(n.x), n.y);
        return sampleMix(userUV(p));
      }
      void main(){
        vec3 col = (mode==0)? kaleido() : mirrorFX();
        gl_FragColor = vec4(col,1.0);
      }
    `;
    function sh(t,s){const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(o); return o;}
    const pr=gl.createProgram(); gl.attachShader(pr, sh(gl.VERTEX_SHADER,vs)); gl.attachShader(pr, sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(pr);
    if(!gl.getProgramParameter(pr,gl.LINK_STATUS)) throw gl.getProgramInfoLog(pr);
    gl.useProgram(pr);

    const quad=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,quad);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]),gl.STATIC_DRAW);
    const aPos=gl.getAttribLocation(pr,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    const U={}; ['texA','texB','mixAB','resolution','time','mode','wedges','zoom','rot','pan','rAmp','rFreq','rSpeed','imgSpin'].forEach(n=>U[n]=gl.getUniformLocation(pr,n));

    function mkTex(){ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);
      const c=document.createElement('canvas'); c.width=c.height=32; const x=c.getContext('2d'); x.fillStyle='#333'; x.fillRect(0,0,32,32); x.fillStyle='#777'; x.fillRect(0,0,16,16);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c); return t;
    }
    deckA.tex=mkTex(); deckB.tex=mkTex();

    function upload(deck){
      const src=(deck.vid && !deck.vid.paused && !deck.vid.ended)? deck.vid : deck.img; if(!src) return;
      const w=src.videoWidth||src.naturalWidth||src.width, h=src.videoHeight||src.naturalHeight||src.height; if(!w||!h) return;
      deck.cvs.width=w; deck.cvs.height=h; (deck.ctx||=deck.cvs.getContext('2d')).drawImage(src,0,0,w,h);
      gl.bindTexture(gl.TEXTURE_2D, deck.tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,deck.cvs);
    }

    renderer = {
      draw(){
        fit(); upload(deckA); upload(deckB);
        gl.useProgram(pr);
        gl.uniform1i(U.texA,0); gl.uniform1i(U.texB,1);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, deckA.tex);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, deckB.tex);
        gl.uniform2f(U.resolution, cv.width, cv.height);
        const t=(performance.now()-t0)/1000.0;
        gl.uniform1f(U.time, t);
        gl.uniform1i(U.mode, state.mode);
        gl.uniform1f(U.wedges, state.wedges);
        gl.uniform1f(U.zoom, state.zoom);
        gl.uniform1f(U.rot, state.rot);
        gl.uniform2f(U.pan, state.panx, state.pany);
        gl.uniform1f(U.rAmp, state.rAmp);
        gl.uniform1f(U.rFreq, state.rFreq);
        gl.uniform1f(U.rSpeed, state.rSpeed);
        /* SLOW SPIN: tiny spin range in UI; shader multiplies by time */
        gl.uniform1f(U.imgSpin, state.spinHz * 6.28318530718 * t);
        gl.uniform1f(U.mixAB, state.mix);
        gl.viewport(0,0,cv.width,cv.height);
        gl.drawArrays(gl.TRIANGLES,0,6);
      }
    };
  } else {
    // very light 2D fallback
    const ctx2=cv.getContext('2d');
    function draw2D(){
      fit(); ctx2.clearRect(0,0,cv.width,cv.height);
      ctx2.fillStyle='#000'; ctx2.fillRect(0,0,cv.width,cv.height);
    }
    renderer={draw:draw2D};
  }

  function loop(){ renderer.draw(); requestAnimationFrame(loop); }
  fit(); loop();

  // Hide/Show controls
  const hideBtn = document.getElementById('hidePanel');
  const panel   = document.getElementById('kbar');
  hideBtn.addEventListener('click', ()=>{
    const isHidden = panel.style.display==='none';
    panel.style.display = isHidden ? 'grid' : 'none';
    hideBtn.textContent = isHidden ? 'Hide Controls' : 'Show Controls';
  });

  /* ===== Touch: 1-finger pan, 2-finger pinch + twist (restored) ===== */
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const pts = new Map(); // id -> {x,y}
  let baseline = { panx:0,pany:0, zoom:1, rot:0, cX:0,cY:0, dist:0, ang:0 };

  function centroid(){ let sx=0,sy=0; for(const p of pts.values()){sx+=p.x; sy+=p.y} const n=pts.size; return {x:sx/n,y:sy/n,n}; }
  function distAng(){ const it=pts.values(); const a=it.next().value, b=it.next().value; const dx=b.x-a.x, dy=b.y-a.y; return {dist:Math.hypot(dx,dy), ang:Math.atan2(dy,dx)}; }
  function snapshotBaseline(){
    baseline.panx=state.panx; baseline.pany=state.pany; baseline.zoom=state.zoom; baseline.rot=state.rot;
    if(pts.size>=2){ const c=centroid(); baseline.cX=c.x; baseline.cY=c.y; const da=distAng(); baseline.dist=da.dist; baseline.ang=da.ang; }
  }
  function syncUI(){ UI.panx.value=state.panx; UI.pany.value=state.pany; UI.zoom.value=state.zoom; UI.rot.value=state.rot; }

  cv.addEventListener('pointerdown', (e)=>{ cv.setPointerCapture(e.pointerId); pts.set(e.pointerId,{x:e.clientX,y:e.clientY}); snapshotBaseline(); }, {passive:false});
  cv.addEventListener('pointermove', (e)=>{
    if(!pts.has(e.pointerId)) return;
    pts.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const c=centroid();
    if(c.n===1){
      // 1-finger pan
      state.panx = clamp(state.panx + (e.movementX/innerWidth)*2, -4, 4);
      state.pany = clamp(state.pany - (e.movementY/innerHeight)*2, -4, 4);
      syncUI();
    } else if (c.n>=2){
      // 2-finger pinch + twist + translate
      const {dist, ang} = distAng();
      const scale = baseline.dist ? (dist / baseline.dist) : 1;
      state.zoom = clamp(baseline.zoom * scale, +UI.zoom.min || 0.2, +UI.zoom.max || 6);

      let dAng = ang - baseline.ang;
      if (dAng > Math.PI)  dAng -= 2*Math.PI;
      if (dAng < -Math.PI) dAng += 2*Math.PI;
      state.rot = clamp(baseline.rot + dAng, +UI.rot.min || -Math.PI, +UI.rot.max || Math.PI);

      state.panx = clamp(baseline.panx + ((c.x - baseline.cX)/innerWidth)*2, -4, 4);
      state.pany = clamp(baseline.pany - ((c.y - baseline.cY)/innerHeight)*2, -4, 4);
      syncUI();
    }
    e.preventDefault();
  }, {passive:false});
  function up(e){ pts.delete(e.pointerId); if(pts.size>0) snapshotBaseline(); }
  cv.addEventListener('pointerup', up, {passive:false});
  cv.addEventListener('pointercancel', up, {passive:false});
  cv.addEventListener('pointerleave', up, {passive:false});
})(); // end kaleidoscope IIFE

/* ================= Global Slots API for inserts ================= */
(() => {
  const lanes = {
    top:    { el: document.getElementById('lane-top'),    count: 6,  prefix:'T' },
    bottom: { el: document.getElementById('lane-bottom'), count: 6,  prefix:'B' },
    left:   { el: document.getElementById('lane-left'),   count: 8,  prefix:'L' },
    right:  { el: document.getElementById('lane-right'),  count: 8,  prefix:'R' },
  };
  const slots = new Map();
  for (const k in lanes){
    const L = lanes[k];
    for (let i=1;i<=L.count;i++){
      const s=document.createElement('div'); s.className='slot'; s.dataset.slotId=`${L.prefix}${i}`;
      L.el.appendChild(s); slots.set(`${L.prefix}${i}`, s);
    }
  }
  function spawnButton(slotId, icon='‚ú®', label='Insert', onClick=()=>{}){
    const slot=slots.get(slotId); if(!slot) return;
    const b=document.createElement('button'); b.className='appear'; b.innerHTML=`<span>${icon}</span><span>${label}</span>`;
    b.onclick=(e)=>{e.stopPropagation(); onClick();}; slot.style.pointerEvents='none'; b.style.pointerEvents='auto';
    slot.innerHTML=''; slot.appendChild(b);
    return b;
  }
  window.AppSlots = { spawnButton }; // inserts can call this
})();

/* ================== Snapshot + Record (canvas capture) ================== */
(() => {
  const cv = document.getElementById('kaleido');
  const btnSnap = document.getElementById('kSnap');
  const btnRecS = document.getElementById('kRecStart');
  const btnRecP = document.getElementById('kRecStop');

  // Snapshot PNG
  if (btnSnap) {
    btnSnap.addEventListener('click', ()=>{
      try{
        const url = cv.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = URL.createObjectURL((()=>{const b64=url.split(',')[1]; const bin=atob(b64); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i); return new Blob([arr],{type:'image/png'});})());
        a.download = 'kaleidoscope.png'; a.click();
      }catch(e){
        alert('Snapshot failed (CORS if external images without headers).');
        console.error(e);
      }
    });
  }

  // Record WEBM (no audio)
  let stream=null, rec=null, chunks=[];
  function ensureStream(){ if(!stream && cv.captureStream) stream=cv.captureStream(60); return !!stream; }
  if (btnRecS && btnRecP){
    btnRecS.addEventListener('click', ()=>{
      if(!ensureStream()) return alert('canvas.captureStream not supported.');
      if(!('MediaRecorder' in window)) return alert('MediaRecorder not supported.');
      chunks=[];
      try{ rec = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp9' }); }
      catch{ rec = new MediaRecorder(stream); }
      rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      rec.onstop = ()=>{
        const blob = new Blob(chunks, { type:'video/webm' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download='kaleidoscope.webm'; a.click();
        chunks=[];
      };
      rec.start();
      btnRecS.disabled = true; btnRecP.disabled = false;
    });
    btnRecP.addEventListener('click', ()=>{
      try{ if(rec && rec.state!=='inactive') rec.stop(); }catch(e){ console.error(e); }
      btnRecS.disabled = false; btnRecP.disabled = true;
    });
  }
})();
</script>
</body>
</html>
